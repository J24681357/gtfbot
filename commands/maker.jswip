var stats = require("/app/functions/profile/f_stats");
var emote = require("/app/index");
var gtftools = require("/app/functions/misc/f_tools");

const Discord = require("discord.js");
const client = new Discord.Client();
var gtffile = process.env
////////////////////////////////////////////////////

module.exports = {
  name: "maker",
  cooldown: 3,
  delete: true,
  description: "Test",
  aliases: ["course"],
  usedduringrace: false,
  usedinlobby: false,
  execute(msg, query, msgauthorid) {
    /* Setup */
    const embed = new Discord.RichEmbed();
    embed.setColor(0x0151b0);

    var user = msg.guild.members.get(msgauthorid).user.username;
    embed.setAuthor(
      user,
      msg.guild.members.get(msgauthorid).user.displayAvatarURL
    );
    var args =
      "\n" +
      "`Args: !maker`" +
      "\n";

    /* Setup */
    var results = " ";
    embed.setTitle("__**Course Maker**__")
    
        if (msgauthorid != "237450759233339393") {
      return msg.channel.send("No.")
    }
    
  var grid =   [[emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent],[emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent],[emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent],[emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent],[emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent],[emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent],[emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent],[emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent,emote.transparent]]
  var start = true
  var startposition = [4,4]
  var current = [startposition[0],startposition[1]]
  var next = [4,5]
  var prev = [];
  var pieceselect = false;
  var nextpiece = null
  var finished = false
    /*[1,1, true],[1,-1],[-1,-1], [-1,1]*/
  var direction = [[0,1, true],  [1,0, true],  [0, -1, true], [-1, 0, true]]
  var validdirection = []
  var valid = [];
  var validpieces = []
  /* [name, type, ??, [directions]]*/
  var track = ["Generic Track", 0]
  
  var pieces = [
                [emote.s2, 2, 0, [[0, 0], [2,2]],0.1 ],
                [emote.s2r1, 2, 0, [[1, 1], [3,3]],0.1 ],
            
                [emote.c242, 2, 0, [ [0, 1], [3, 2] ], 0.1 ], 
                [emote.c242r1,2, 0, [ [0, 3], [1, 2]], 0.1 ],
                [emote.c242r2,2, 0, [ [1,0], [2,3]],0.1],
                [emote.c242r3,2, 0, [ [3, 0], [2,1]],0.1],
               ]
                  
                /*[emote.c0342,2, 0, [[3, 1]]],*/
                
                /*]*/
  /* Other
  [emote.s1, 1, 0, [[0, 0]] [2,2]],
    [emote.s3,3, 0, [[0, 0], [2,2]] ],
                  [emote.s3r1, 3, 0, [[1, 1]]],
             [emote.s1r1, 1, 0, [[1, 1]]],
                           [emote.c0342,3, 0, [[0, 1]] ]
                                           [emote.c0142,1, 0, [ [0, 1] ]],
*/
  
  var type = 2
  var dir = 0
  var vpselect = 0
    
  function possiblemoves() {
    validdirection = direction.map(function(d) {
      var x = current[0] + d[0]
      var y = current[1] + d[1]

      if (x >= 8 || x <= -1 || y >= 9 || y <= -1) {
        d[2] = false
      }
      if (typeof grid[x] === 'undefined') {
           d[2] = false
        return d
      }
      if (typeof grid[x][y] === "undefined") {
           d[2] = false
        return d
      }

      if (grid[x][y] == "ðŸŸ¦") {
        return d
      }
      
      if (grid[x][y].name.includes("t_")) {
        d[2] = true
      } else {
        d[2] = false
      }
      return d
    })
    validpieces = pieces.filter(function(x){
      if (x[1] != type){
        return false;
      }
      var index = 0
      for (index; index < x[3].length; index++) {
        if (x[3][index][0] == dir) {
  
          return true
        }
      }
      return false
  })

  }
  
  function createfinalgrid() {
    embed.setColor(0x0151b0);
    possiblemoves()
    if (start) {
      grid[current[0]][current[1]] = emote.s2
    }
    if (pieceselect) {
      grid[current[0]][current[1]] = nextpiece
      vpselect = 0
      embed.addField("Track Length", Math.round(100 *  track[1]) / 100 + " km", true)
      embed.addField("Piece", validpieces[vpselect][0], true)
      pieceselect = false   
      if (start) {
        start = false
    }
    } else {
      embed.addField("Track Length", Math.round(100 *  track[1]) / 100 + " km", true)
      embed.addField("Piece", validpieces[vpselect][0], true)
    }
    var x = next[0] 
    var y = next[1]
    if (!finished) {
    grid[x][y] = "ðŸŸ¦"
    } else {
      grid[x][y] = nextpiece
    }
    
    results = grid.map(x => x.join("")).join("\n")
    embed.setDescription(results)
  }
    
    createfinalgrid()
    msg.channel.send(embed).then(msg => {
      function toggleselect() {
        if (dir >= validdirection.length - 1) {
          dir = 0
        } else {
          while (!validdirection[dir][2]) {
            dir++
          }
        }
        grid[next[0]][next[1]] = emote.transparent
        var x = current[0] + validdirection[dir][0]
        var y = current[1] + validdirection[dir][1]
        next = [x,y]
        createfinalgrid()
        msg.edit(embed)
      }
      function togglepiece() {
        vpselect += 1
        if (vpselect >= validpieces.length) {
          vpselect = 0
        }
        embed.fields = []
        createfinalgrid()
        msg.edit(embed)
      }
      function selectpiece() {
        var gridcopy = grid[next[0]][next[1]]
        var currentcopy = [current[0], current[1]]
        var dircopy = validpieces[vpselect][3]
        var dircopysimple = dir
        var typecopy = type
        var lengthcopy = Math.round(100 * validpieces[vpselect][4]) / 100
        grid[next[0]][next[1]] = validpieces[vpselect][0]
        current = [next[0], next[1]]
        type = validpieces[vpselect][1]
        track[1] += Math.round(100 * validpieces[vpselect][4]) / 100
        
        var index = 0
        for (index; index < validpieces[vpselect][3].length; index++) {
          if (validpieces[vpselect][3][index][0] == dir) {
            dir = validpieces[vpselect][3][index][1]
          }
        }        
        nextpiece = validpieces[vpselect][0]
                
        var r = current[0] + validdirection[dir][0]
        var r2 = current[1] + validdirection[dir][1]
        var dirrr = dir
        
        
        possiblemoves()
        if (!validdirection[dir][2] && !((r == startposition[0]) && (r2 == startposition[1]))) {
          grid[next[0]][next[1]] = gridcopy
          current = currentcopy
          dir = dircopysimple
          type = typecopy
          track[1] -= lengthcopy
          nextpiece = null
          vpselect = 0
          embed.fields = []
          createfinalgrid()
          embed.setColor(0xFF0000)
          msg.edit(embed)
          return
        }

        prev.push([gridcopy, currentcopy, dircopy, typecopy, lengthcopy])
        
        var repeat = 1;
        while (!validdirection[dir][2]) {
            dir++
              if (dir >= validdirection.length - 1) {
                dir = 0
            } 
          repeat++
          if (repeat == 3) {
            dirrr = 0
            break;
          }
        }
        if ((r == startposition[0]) && (r2 == startposition[1])) {
          if (dirrr == 0) {
        finished = true
        embed.fields = []
        createfinalgrid()
        embed.setColor(0x216C2A)
        msg.edit(embed)
        return
          } else {
        grid[next[0]][next[1]] = gridcopy
          current = currentcopy
          dir = dircopysimple
          type = typecopy
          track[1] -= lengthcopy
          nextpiece = null
          vpselect = 0
          
          embed.fields = []
          createfinalgrid()
          embed.setColor(0xFF0000)
          msg.edit(embed)
          return
          }
        


        }
        
        
        var x = current[0] + validdirection[dir][0]
        var y = current[1] + validdirection[dir][1]
        next = [x,y]
        pieceselect = true
        
        embed.fields = []
        createfinalgrid()
        msg.edit(embed)
      }
      function deletepiece() {
        if (prev.length == 0) {
          embed.setColor(0x0151b0);
          msg.edit(embed)
          return
        }
        var revert = prev.pop()
        
        /*grid[revert[1][0]][revert[1][1]] = emote.transparent*/

        grid[next[0]][next[1]] = emote.transparent
        
        var x = current[0] - validdirection[dir][0]
        var y = current[1] - validdirection[dir][1]
        var xnext = next[0] - validdirection[dir][0]
        var ynext = next[1] - validdirection[dir][1]
        next = [xnext,ynext]
        current = [x,y]

        
        for (var index = 0; index < revert[2].length; index++) {
          if (revert[2][index][1] == dir) {
            dir = revert[2][index][0]
          }
        }
        type = revert[3]
         track[1] -= revert[5]
        
        possiblemoves()
        embed.fields = []
        createfinalgrid()
        msg.edit(embed)
      }
      
      var emojilist = [["âœ…", "âœ…", selectpiece], ["ðŸ›£", "ðŸ›£", togglepiece], ["ðŸ”„", "ðŸ”„", deletepiece]]
      
      gtftools.createreactions(emojilist, msg, msgauthorid)
    })
  }
};